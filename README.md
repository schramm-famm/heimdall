# Heimdall
Heimdall is the single point of entry to Riht. It creates and distributes JSON
Web Tokens (JWTs) to users to be used with their requests. Heimdall will check
requests to protected routes for an associated token before fowarding it to the
proper service.

## Environment Variables
Heimdall routes requests using environment variables associated with the
microservice for that endpoint. When a microservice is deployed behind heimdall,
it should set an environment variable in heimdall (format:
`<APPNAME_IN_CAPS>_HOST`) with its domain name or IP address.

## APIS
### `POST /heimdall/v1/token`
This route handles the creation of the tokens. The request must have the header
`Content-Type: application/json` and a body containing the `email` and
`password` of the user. The typical use case is shown in the figure below.

![Typical use case for this API](https://github.com/schramm-famm/docs/blob/master/diagrams/heimdall/Token_Creation.png "Token Creation")

### `POST /heimdall/v1/token/auth`
This route checks whether a given token is valid. The request must have the
header `Content-Type: application/json` and a body containg the `token` to be
validated. If the token is valid, the response will be `200 OK` with a JSON body
containing the token's associated `user_id`. If the token is invalid, the
response will be `404 Not Found`.

### `GET /patches/v1/connect/{conversation_id}`
This route handles the creation of a WebSocket connection with the Patches
service. Authorization for requests to this route will not be handled by
Heimdall directly, but will instead be deferred until the WebSocket connection
is established. The client will be required to send their token as the first
message that they send through the WebSocket. The Patches service can then call
Heimdall's `POST /heimdall/v1/token/auth` API to validate the token.

### `GET/POST/PUT /*`
This route is hit for any request to the system that isn't one of the above
endpoints. It will check the `Authorization` header of the request
for the value `Bearer <token>` where `<token>` is a valid and non-expired token
that was generated by Heimdall. If it is valid, the request is fowarded to the
internal load balancer to be sent to the proper service. If not, the user will
be denied access.

## Developer Documentation
### Dependencies
Heimdall must be tested and ran in the virtual machine environment provided in
the [VM repo](https://github.com/schramm-famm/vm). This environment comes with
docker, golang, kubernetes, and many other dependencies pre-installed.

### Project
The project directory is laid out as following:
```
heimdall/
|-- Dockerfile
|-- go.mod
|-- go.sum
|-- Makefile
|-- README.md
|-- app/
|   |-- server.go
|-- handlers/
    |-- handlers.go
    |-- handlers_test.go
|-- models/
    |-- models.go
|-- terraform/
    |-- main.tf
    |-- variables.tf
    |-- modules/
        |-- main.tf
        |-- variables.tf
```

#### Dockerfile
The Dockerfile dictates how to build the docker container. This Dockerfile has
two stages. The first stage uses the golang container base and downloads the
module dependencies and builds the go app binary. The second stage uses the most
barebones container base and moves only the important binaries into the
container.

#### go.mod and go.sum
These files handle the dependencies of the project. `go.mod` was created by
running `go mod init` in the root of the directory and `go.sum` was created
during the first execution of `go run ./...` or `go build ./...`.

#### Makefile
The Makefile defines a set of tasks to be executed. When the command `make` or
`make help` is executed in the root directory, the usage of the command is
outputted. This file can be used to build the app binaries, run tests, build the
docker images, and more.

#### README.md
The README.md is a markdown file that provides documentation for the repository.

#### server.go
This file is the entrypoint of Heimdall. The `app` directory is the `main`
package so a binary for it is created when `go build ./...` is executed. When
executed, this file will start the HTTPS server that listens on the 443 port for
requests to the two routes outlined in [APIs](#apis).

#### handlers.go
This file contains the definitions of the route handlers for the server.

#### handlers_test.go
This is the test file for `handlers.go`. It contains unit tests for the handlers
defined in `handlers.go`.

#### models.go
This files contains the definitions of the `User` and `TokenClaims` structs.

### Terraform
To deploy `heimdall` and its direct dependencies in AWS, use `terraform`:
1. Change directories to the `terraform/` directory.
2. Create a file in the `terraform/` directory called `terraform.tfvars` and fill it out like this:
```
name = "WHATEVER_UNIQUE_NAME_YOU_WANT"
access_key = "YOUR_AWS_ACCESS_KEY_ID"
secret_key = "YOUR_AWS_SECRET_ACCESS_KEY"
```
3. Run `terraform init` to initialize the Terraform working directory.
4. Run `terraform plan` to see what resources will be created and then `terraform apply` to create the resources. Enter
`yes` when prompted by Terraform.
5. Once the previous command is done running, the AWS resources should now be visible in the AWS console (UI) and ready
to be used for development/testing. Once you're done using the resources, run `terraform destroy`. Enter `yes` when
prompted by Terraform.

### Developer Process
The RSA private and public keys are generated whenever the app is built and is
put into the `tmp/` folder. The path of the keys must be set as the
`PRIVATE_KEY` environment variable and the self-signed certificate must be set
as the `SERVER_CERT` environment variable, relative to where the command is
being run. For example in the `Makefile` before the command `./tmp/app`, the
`PRIVATE_KEY` variable is exported as `tmp/id_rsa` and the `SERVER_CERT` variable
is exported as `tmp/server.crt`.

When implementing features, tests should be made in parallel with the
implementation process. Each new feature must have corresponding tests to
validate the new functionality.

To run Heimdall within the developer environment, `make run` can be executed to
build and run the binaries quickly. To create the docker image and start the
detached container, execute `make docker-run`.
